# 《春节模拟器》游戏系统架构文档

## 版本信息
- **版本**: v1.0.0
- **日期**: 2024年
- **文档类型**: 技术架构文档

---

## 目录
1. [系统概述](#1-系统概述)
2. [数据结构设计](#2-数据结构设计)
3. [JSON数据规范](#3-json数据规范)
4. [游戏核心机制](#4-游戏核心机制)
5. [存档系统](#5-存档系统)
6. [附录](#6-附录)

---

## 1. 系统概述

### 1.1 游戏基本信息
| 项目 | 说明 |
|------|------|
| 游戏名称 | 春节模拟器 |
| 游戏类型 | 生存模拟 + 叙事选择 |
| 游戏平台 | Web (HTML5) |
| 游戏时长 | 9天（第1天至第9天） |
| 时间粒度 | 每天分早/中/晚三个时段 |

### 1.2 核心属性系统

#### 1.2.1 基础属性（6项）
| 属性名 | 英文标识 | 初始范围 | 说明 |
|--------|----------|----------|------|
| 存款 | money | 0-50000 | 单位：元，可负值（借贷） |
| 体重 | weight | 40-120 | 单位：kg |
| 面子 | face | 0-100 | 社交地位与尊严 |
| 心情 | mood | 0-100 | 情绪状态 |
| 健康 | health | 0-100 | 身体健康程度 |
| 运气 | luck | 0-100 | 随机事件影响因子 |

#### 1.2.2 属性边界规则
```javascript
// 属性边界常量
const ATTRIBUTE_BOUNDS = {
    money: { min: -50000, max: 100000 },      // 存款：可借贷5万，上限10万
    weight: { min: 30, max: 200 },             // 体重：30-200kg
    face: { min: 0, max: 100 },                // 面子：0-100
    mood: { min: 0, max: 100 },                // 心情：0-100
    health: { min: 0, max: 100 },              // 健康：0-100
    luck: { min: 0, max: 100 }                 // 运气：0-100
};
```

### 1.3 时间系统

#### 1.3.1 时间结构
```
游戏总时长：9天
├── 第1天（腊月二十九）
├── 第2天（除夕）★ 关键日
├── 第3天（初一）★ 关键日
├── 第4天（初二）
├── 第5天（初三）
├── 第6天（初四）
├── 第7天（初五）
├── 第8天（初六）
└── 第9天（初七/返程日）★ 结局日

每天时段：早(0) → 中(1) → 晚(2)
```

#### 1.3.2 时间推进规则
- 每个时段触发一个事件
- 选择选项后自动推进到下一时段
- 当天时段耗尽后进入下一天
- 第9天晚时段结束后触发结局判定

---

## 2. 数据结构设计

### 2.1 角色数据结构

#### 2.1.1 角色定义（Role / Character）
```typescript
interface Character {
    // 基础信息
    id: string;                    // 角色唯一标识（如："programmer"）
    name: string;                  // 角色名称（如："程序员小王"）
    description: string;           // 角色背景描述
    avatar: string;                // 头像资源路径
    
    // 初始属性
    initialAttributes: {
        money: number;             // 初始存款
        weight: number;            // 初始体重
        face: number;              // 初始面子
        mood: number;              // 初始心情
        health: number;            // 初始健康
        luck: number;              // 初始运气
    };
    
    // 角色特性（被动效果）
    traits: Trait[];
    
    // 专属事件池
    exclusiveEvents: string[];     // 事件ID列表
    
    // 解锁条件（可选）
    unlockCondition?: {
        type: 'default' | 'achievement' | 'previous_play';
        requirement?: string;
    };
}

interface Trait {
    id: string;
    name: string;
    description: string;
    effect: TraitEffect;
}

type TraitEffect = 
    | { type: 'attribute_modifier'; attribute: string; value: number; condition?: string }
    | { type: 'event_probability'; eventType: string; multiplier: number }
    | { type: 'special_option'; eventId: string; optionId: string };
```

#### 2.1.2 角色配置示例
```json
{
    "id": "programmer",
    "name": "程序员小王",
    "description": "北漂程序员，年终奖刚发，面对亲戚的灵魂拷问...",
    "avatar": "assets/characters/programmer.png",
    "initialAttributes": {
        "money": 30000,
        "weight": 70,
        "face": 50,
        "mood": 60,
        "health": 65,
        "luck": 50
    },
    "traits": [
        {
            "id": "tech_savvy",
            "name": "技术宅",
            "description": "电子设备相关事件获得额外选项",
            "effect": {
                "type": "special_option",
                "eventId": "phone_repair",
                "optionId": "diy_fix"
            }
        },
        {
            "id": "high_income",
            "name": "高薪职业",
            "description": "红包支出增加20%",
            "effect": {
                "type": "attribute_modifier",
                "attribute": "money",
                "value": -0.2,
                "condition": "red_envelope_event"
            }
        }
    ],
    "exclusiveEvents": ["code_question", "tech_support"],
    "unlockCondition": { "type": "default" }
}
```

#### 2.1.3 预设角色列表（10个）
| ID | 名称 | 职业特点 | 初始存款 | 特色 |
|----|------|----------|----------|------|
| programmer | 程序员小王 | 高薪但加班 | 30000 | 技术宅，红包压力大 |
| teacher | 教师小李 | 稳定体面 | 15000 | 面子高，被请教教育问题 |
| doctor | 医生小张 | 忙碌专业 | 25000 | 健康相关事件优势 |
| freelancer | 自由职业者 | 收入不稳定 | 10000 | 运气波动大 |
| student | 大学生小陈 | 无收入 | 2000 | 收红包为主 |
| entrepreneur | 创业者小刘 | 高风险高回报 | 50000 | 存款波动大 |
| civil_servant | 公务员小赵 | 稳定保守 | 20000 | 面子高，约束多 |
| artist | 艺术家小吴 | 追求理想 | 8000 | 心情相关事件优势 |
| sales | 销售小周 | 社交达人 | 20000 | 面子相关事件优势 |
| unemployed | 待业青年小马 | 求职中 | 5000 | 特殊挑战模式 |

---

### 2.2 事件数据结构

#### 2.2.1 事件定义（Event）
```typescript
interface Event {
    // 基础信息
    id: string;                    // 事件唯一标识
    title: string;                 // 事件标题
    description: string;           // 事件描述文本
    category: EventCategory;       // 事件类别
    
    // 触发条件
    triggerConditions: TriggerCondition[];
    
    // 互斥事件（已触发则不再触发）
    mutuallyExclusive?: string[];
    
    // 前置事件（必须先触发）
    prerequisiteEvents?: string[];
    
    // 后置事件（触发后解锁）
    unlockEvents?: string[];
    
    // 选项列表
    options: Option[];
    
    // 默认选项（当所有选项不可用时显示）
    defaultOption?: Option;
    
    // 事件权重（影响随机触发概率）
    weight: number;
    
    // 是否只能触发一次
    onceOnly: boolean;
    
    // 关联角色（专属事件）
    exclusiveTo?: string[];
    
    // 视觉资源
    assets: {
        background?: string;
        character?: string;
        icon?: string;
    };
}

type EventCategory = 
    | 'family'      // 家庭互动
    | 'social'      // 社交应酬
    | 'food'        // 饮食相关
    | 'money'       // 金钱相关
    | 'health'      // 健康相关
    | 'random'      // 随机事件
    | 'story'       // 剧情事件
    | 'special';    // 特殊事件

interface TriggerCondition {
    type: 'time' | 'attribute' | 'probability' | 'event_history' | 'character';
    params: Record<string, any>;
}
```

#### 2.2.2 触发条件详细定义
```typescript
// 时间条件
interface TimeCondition extends TriggerCondition {
    type: 'time';
    params: {
        days?: number[];           // 指定天数 [1,2,3,...]
        periods?: number[];        // 指定时段 [0,1,2]
        dayRange?: { min: number; max: number };
    };
}

// 属性条件
interface AttributeCondition extends TriggerCondition {
    type: 'attribute';
    params: {
        attribute: string;         // 属性名
        operator: '>' | '<' | '>=' | '<=' | '==' | '!=';
        value: number;
    };
}

// 概率条件
interface ProbabilityCondition extends TriggerCondition {
    type: 'probability';
    params: {
        baseRate: number;          // 基础概率 0-1
        luckModifier?: boolean;    // 是否受运气影响
    };
}

// 事件历史条件
interface EventHistoryCondition extends TriggerCondition {
    type: 'event_history';
    params: {
        eventId: string;
        triggered: boolean;        // 是否已触发
        choiceIndex?: number;      // 特定选择
    };
}

// 角色条件
interface CharacterCondition extends TriggerCondition {
    type: 'character';
    params: {
        characterIds: string[];    // 允许的角色列表
    };
}
```

#### 2.2.3 事件配置示例
```json
{
    "id": "new_year_eve_dinner",
    "title": "年夜饭",
    "description": "全家人围坐在一起吃年夜饭，妈妈做了你最爱吃的红烧肉...",
    "category": "family",
    "triggerConditions": [
        {
            "type": "time",
            "params": { "days": [2], "periods": [1] }
        }
    ],
    "weight": 100,
    "onceOnly": true,
    "options": [
        {
            "id": "eat_more",
            "text": "大吃一顿，难得回家",
            "effects": [
                { "attribute": "weight", "value": 2 },
                { "attribute": "mood", "value": 15 },
                { "attribute": "health", "value": -5 }
            ]
        },
        {
            "id": "eat_normal",
            "text": "正常吃饭，注意节制",
            "effects": [
                { "attribute": "weight", "value": 0.5 },
                { "attribute": "mood", "value": 5 },
                { "attribute": "health", "value": 2 }
            ]
        },
        {
            "id": "diet",
            "text": "控制饮食，保持身材",
            "conditions": [
                { "type": "attribute", "params": { "attribute": "health", "operator": ">=", "value": 60 } }
            ],
            "effects": [
                { "attribute": "weight", "value": -0.5 },
                { "attribute": "mood", "value": -5 },
                { "attribute": "face", "value": 5 }
            ]
        }
    ],
    "assets": {
        "background": "assets/events/dinner_bg.jpg",
        "icon": "assets/icons/food.png"
    }
}
```

---

### 2.3 选项数据结构

#### 2.3.1 选项定义（Option）
```typescript
interface Option {
    // 基础信息
    id: string;                    // 选项唯一标识
    text: string;                  // 选项显示文本
    
    // 显示条件（不满足则不显示此选项）
    visibilityConditions?: Condition[];
    
    // 可用条件（显示但不可选）
    availabilityConditions?: Condition[];
    
    // 不可用时的提示文本
    unavailableText?: string;
    
    // 属性效果
    effects: Effect[];
    
    // 后续事件（立即触发或加入待触发队列）
    followUpEvents?: {
        eventId: string;
        delay?: 'immediate' | 'next_period' | 'next_day';
        probability?: number;
    }[];
    
    // 特殊结果
    specialOutcome?: {
        type: 'game_over' | 'ending_trigger' | 'achievement' | 'story_branch';
        value: string;
    };
    
    // 视觉反馈
    feedback?: {
        text: string;              // 结果描述文本
        animation?: string;        // 动画效果
        sound?: string;            // 音效
    };
}

interface Effect {
    // 效果类型
    type: 'attribute' | 'item' | 'flag' | 'event' | 'special';
    
    // 属性效果
    attribute?: string;            // 属性名
    value?: number;                // 变化值（可为负）
    operation?: 'add' | 'set' | 'multiply';  // 操作类型
    
    // 物品效果
    itemId?: string;
    itemCount?: number;
    
    // 标记效果
    flagName?: string;
    flagValue?: boolean | number | string;
    
    // 事件效果
    eventId?: string;
    
    // 特殊效果
    specialType?: string;
    specialParams?: Record<string, any>;
    
    // 条件效果（满足条件才生效）
    condition?: Condition;
}

interface Condition {
    type: 'attribute' | 'item' | 'flag' | 'event' | 'random' | 'character';
    params: Record<string, any>;
}
```

#### 2.3.2 效果计算示例
```javascript
// 属性效果计算
{
    "type": "attribute",
    "attribute": "money",
    "value": -500,
    "operation": "add"
}
// 结果: money = money - 500

// 带条件的效果
{
    "type": "attribute",
    "attribute": "face",
    "value": 10,
    "condition": {
        "type": "attribute",
        "params": { "attribute": "money", "operator": ">=", "value": 10000 }
    }
}
// 结果: 如果存款>=10000，面子+10

// 随机效果
{
    "type": "attribute",
    "attribute": "luck",
    "value": { "min": -5, "max": 10 },
    "operation": "add"
}
// 结果: 运气增加 -5 到 10 之间的随机值
```

---

### 2.4 结局数据结构

#### 2.4.1 结局定义（Ending）
```typescript
interface Ending {
    // 基础信息
    id: string;                    // 结局唯一标识
    title: string;                 // 结局标题
    description: string;           // 结局描述文本
    category: EndingCategory;      // 结局类别
    
    // 解锁条件（满足任一条件组即可）
    unlockConditions: ConditionGroup[];
    
    // 结局评分
    score: {
        base: number;              // 基础分数
        modifiers: ScoreModifier[];
    };
    
    // 视觉资源
    assets: {
        background: string;
        achievement?: string;
        music?: string;
    };
    
    // 是否隐藏结局
    hidden: boolean;
    
    // 解锁提示（隐藏结局的提示文本）
    unlockHint?: string;
}

type EndingCategory = 
    | 'perfect'     // 完美结局
    | 'good'        // 好结局
    | 'normal'      // 普通结局
    | 'bad'         // 坏结局
    | 'secret';     // 隐藏结局

interface ConditionGroup {
    // 条件组内的所有条件必须同时满足
    conditions: EndingCondition[];
    priority: number;              // 优先级（数字越大越优先）
}

type EndingCondition = 
    | { type: 'attribute'; attribute: string; operator: string; value: number }
    | { type: 'event_triggered'; eventId: string; choiceIndex?: number }
    | { type: 'flag_set'; flagName: string; flagValue: any }
    | { type: 'combination'; conditions: EndingCondition[] };

interface ScoreModifier {
    condition: EndingCondition;
    value: number;
}
```

#### 2.4.2 结局配置示例
```json
{
    "id": "wealthy_return",
    "title": "衣锦还乡",
    "description": "你带着丰厚的存款和满满的成就感回到城市，这个春节你过得非常成功！",
    "category": "perfect",
    "unlockConditions": [
        {
            "conditions": [
                { "type": "attribute", "attribute": "money", "operator": ">=", "value": 20000 },
                { "type": "attribute", "attribute": "face", "operator": ">=", "value": 80 },
                { "type": "attribute", "attribute": "mood", "operator": ">=", "value": 70 }
            ],
            "priority": 100
        }
    ],
    "score": {
        "base": 1000,
        "modifiers": [
            { "condition": { "type": "attribute", "attribute": "health", "operator": ">=", "value": 80 }, "value": 200 }
        ]
    },
    "assets": {
        "background": "assets/endings/success_bg.jpg",
        "music": "assets/music/victory.mp3"
    },
    "hidden": false
}
```

#### 2.4.3 预设结局列表
| ID | 名称 | 类别 | 解锁条件概要 |
|----|------|------|--------------|
| wealth_legend | 财富传奇 | 完美 | 存款>50000，面子>90 |
| happy_family | 阖家欢乐 | 完美 | 心情>90，健康>80，面子>70 |
| balanced_life | 平衡人生 | 好 | 所有属性>50 |
| career_success | 事业有成 | 好 | 存款>30000，面子>70 |
| ordinary_spring | 平凡春节 | 普通 | 无特殊条件 |
| broke_return | 破产返乡 | 坏 | 存款<-10000 |
| family_conflict | 家庭矛盾 | 坏 | 面子<20，心情<20 |
| health_crisis | 健康危机 | 坏 | 健康<10 |
| secret_marriage | 意外姻缘 | 隐藏 | 触发特定事件链 |
| lottery_winner | 彩票中奖 | 隐藏 | 运气>95且触发彩票事件 |

---

### 2.5 物品/道具数据结构

#### 2.5.1 物品定义（Item）
```typescript
interface Item {
    id: string;                    // 物品唯一标识
    name: string;                  // 物品名称
    description: string;           // 物品描述
    category: ItemCategory;        // 物品类别
    
    // 使用效果
    useEffect?: Effect[];
    
    // 被动效果
    passiveEffect?: Effect;
    
    // 是否可消耗
    consumable: boolean;
    
    // 最大堆叠数量
    maxStack: number;
    
    // 价值（用于出售）
    value: number;
    
    // 视觉资源
    icon: string;
}

type ItemCategory = 
    | 'gift'       // 礼物
    | 'food'       // 食物
    | 'medicine'   // 药品
    | 'tool'       // 工具
    | 'special';   // 特殊物品
```

#### 2.5.2 预设物品列表
| ID | 名称 | 类别 | 效果 |
|----|------|------|------|
| red_envelope | 红包 | gift | 送出后面子+，存款- |
| health_product | 保健品 | gift | 送长辈面子+，健康+ |
| snack | 零食 | food | 心情+，体重+ |
| diet_tea | 减肥茶 | medicine | 体重- |
| vitamin | 维生素 | medicine | 健康+ |
| lucky_charm | 护身符 | special | 运气+10（被动） |

---

### 2.6 游戏状态数据结构

#### 2.6.1 运行时游戏状态
```typescript
interface GameState {
    // 游戏元信息
    meta: {
        version: string;           // 游戏版本
        startTime: number;         // 开始时间戳
        lastSaveTime: number;      // 最后存档时间
        playCount: number;         // 游玩次数
    };
    
    // 当前游戏进度
    progress: {
        currentDay: number;        // 当前天数 (1-9)
        currentPeriod: number;     // 当前时段 (0-2)
        totalPeriods: number;      // 已进行的时段数
    };
    
    // 当前角色
    character: {
        id: string;
        currentAttributes: Attributes;
    };
    
    // 属性值
    attributes: Attributes;
    
    // 物品栏
    inventory: {
        [itemId: string]: number;  // 物品ID: 数量
    };
    
    // 事件历史
    eventHistory: EventRecord[];
    
    // 游戏标记
    flags: {
        [flagName: string]: any;
    };
    
    // 待触发事件队列
    pendingEvents: PendingEvent[];
    
    // 已触发的一次性事件
    triggeredOnceEvents: string[];
    
    // 统计数据
    statistics: GameStatistics;
}

interface Attributes {
    money: number;
    weight: number;
    face: number;
    mood: number;
    health: number;
    luck: number;
}

interface EventRecord {
    eventId: string;
    day: number;
    period: number;
    choiceIndex: number;
    choiceId: string;
    timestamp: number;
}

interface PendingEvent {
    eventId: string;
    triggerDay?: number;
    triggerPeriod?: number;
    priority: number;
}

interface GameStatistics {
    totalEvents: number;
    totalChoices: number;
    moneySpent: number;
    moneyEarned: number;
    redEnvelopesGiven: number;
    redEnvelopesReceived: number;
    mealsEaten: number;
    relativesMet: number;
}
```

---


## 3. JSON数据规范

### 3.1 文件组织结构

```
/data
├── /characters
│   ├── characters.json          # 角色列表索引
│   ├── programmer.json          # 程序员角色详情
│   ├── teacher.json             # 教师角色详情
│   └── ...                      # 其他角色
├── /events
│   ├── events.json              # 事件列表索引
│   ├── family_events.json       # 家庭事件组
│   ├── social_events.json       # 社交事件组
│   ├── food_events.json         # 饮食事件组
│   ├── money_events.json        # 金钱事件组
│   ├── health_events.json       # 健康事件组
│   ├── random_events.json       # 随机事件组
│   ├── story_events.json        # 剧情事件组
│   └── special_events.json      # 特殊事件组
├── /endings
│   ├── endings.json             # 结局列表索引
│   └── ending_details.json      # 结局详情
├── /items
│   └── items.json               # 物品数据
└── /config
    ├── game_config.json         # 游戏配置
    ├── attribute_formulas.json  # 属性公式
    └── event_weights.json       # 事件权重配置
```

### 3.2 角色数据JSON规范

#### 3.2.1 角色列表索引 (characters.json)
```json
{
    "version": "1.0.0",
    "lastUpdated": "2024-01-01",
    "characters": [
        {
            "id": "programmer",
            "name": "程序员小王",
            "file": "programmer.json",
            "unlockStatus": "unlocked"
        },
        {
            "id": "teacher",
            "name": "教师小李",
            "file": "teacher.json",
            "unlockStatus": "unlocked"
        }
    ]
}
```

#### 3.2.2 角色详情JSON Schema
```json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "Character Schema",
    "type": "object",
    "required": ["id", "name", "description", "initialAttributes", "traits"],
    "properties": {
        "id": {
            "type": "string",
            "pattern": "^[a-z_]+$",
            "description": "角色唯一标识，小写下划线格式"
        },
        "name": {
            "type": "string",
            "minLength": 2,
            "maxLength": 20,
            "description": "角色显示名称"
        },
        "description": {
            "type": "string",
            "maxLength": 200,
            "description": "角色背景描述"
        },
        "avatar": {
            "type": "string",
            "description": "头像资源路径"
        },
        "initialAttributes": {
            "type": "object",
            "required": ["money", "weight", "face", "mood", "health", "luck"],
            "properties": {
                "money": { "type": "number", "minimum": -50000, "maximum": 100000 },
                "weight": { "type": "number", "minimum": 30, "maximum": 200 },
                "face": { "type": "number", "minimum": 0, "maximum": 100 },
                "mood": { "type": "number", "minimum": 0, "maximum": 100 },
                "health": { "type": "number", "minimum": 0, "maximum": 100 },
                "luck": { "type": "number", "minimum": 0, "maximum": 100 }
            }
        },
        "traits": {
            "type": "array",
            "items": {
                "type": "object",
                "required": ["id", "name", "description", "effect"],
                "properties": {
                    "id": { "type": "string" },
                    "name": { "type": "string" },
                    "description": { "type": "string" },
                    "effect": { "type": "object" }
                }
            }
        },
        "exclusiveEvents": {
            "type": "array",
            "items": { "type": "string" },
            "description": "专属事件ID列表"
        },
        "unlockCondition": {
            "type": "object",
            "properties": {
                "type": { "enum": ["default", "achievement", "previous_play"] },
                "requirement": { "type": "string" }
            }
        }
    }
}
```

### 3.3 事件数据JSON规范

#### 3.3.1 事件列表索引 (events.json)
```json
{
    "version": "1.0.0",
    "eventGroups": [
        {
            "id": "family",
            "name": "家庭事件",
            "file": "family_events.json",
            "description": "与家庭成员互动相关的事件"
        },
        {
            "id": "social",
            "name": "社交事件",
            "file": "social_events.json",
            "description": "与亲友社交相关的事件"
        }
    ],
    "specialEvents": {
        "newYearEve": "new_year_eve_dinner",
        "newYearDay": "new_year_visit"
    }
}
```

#### 3.3.2 事件详情JSON Schema
```json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "Event Schema",
    "type": "object",
    "required": ["id", "title", "description", "category", "triggerConditions", "options"],
    "properties": {
        "id": {
            "type": "string",
            "pattern": "^[a-z_]+$"
        },
        "title": {
            "type": "string",
            "minLength": 1,
            "maxLength": 50
        },
        "description": {
            "type": "string",
            "minLength": 10,
            "maxLength": 500
        },
        "category": {
            "enum": ["family", "social", "food", "money", "health", "random", "story", "special"]
        },
        "triggerConditions": {
            "type": "array",
            "minItems": 1,
            "items": {
                "type": "object",
                "required": ["type", "params"],
                "properties": {
                    "type": {
                        "enum": ["time", "attribute", "probability", "event_history", "character"]
                    },
                    "params": { "type": "object" }
                }
            }
        },
        "mutuallyExclusive": {
            "type": "array",
            "items": { "type": "string" }
        },
        "prerequisiteEvents": {
            "type": "array",
            "items": { "type": "string" }
        },
        "weight": {
            "type": "number",
            "minimum": 0,
            "maximum": 1000,
            "default": 100
        },
        "onceOnly": {
            "type": "boolean",
            "default": false
        },
        "exclusiveTo": {
            "type": "array",
            "items": { "type": "string" }
        },
        "options": {
            "type": "array",
            "minItems": 1,
            "maxItems": 4,
            "items": {
                "$ref": "#/definitions/option"
            }
        },
        "assets": {
            "type": "object",
            "properties": {
                "background": { "type": "string" },
                "character": { "type": "string" },
                "icon": { "type": "string" }
            }
        }
    },
    "definitions": {
        "option": {
            "type": "object",
            "required": ["id", "text", "effects"],
            "properties": {
                "id": { "type": "string" },
                "text": {
                    "type": "string",
                    "minLength": 1,
                    "maxLength": 100
                },
                "visibilityConditions": {
                    "type": "array",
                    "items": { "type": "object" }
                },
                "availabilityConditions": {
                    "type": "array",
                    "items": { "type": "object" }
                },
                "unavailableText": { "type": "string" },
                "effects": {
                    "type": "array",
                    "minItems": 1,
                    "items": {
                        "type": "object",
                        "required": ["type"],
                        "properties": {
                            "type": { "enum": ["attribute", "item", "flag", "event", "special"] },
                            "attribute": { "type": "string" },
                            "value": {},
                            "operation": { "enum": ["add", "set", "multiply"], "default": "add" },
                            "condition": { "type": "object" }
                        }
                    }
                },
                "followUpEvents": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "required": ["eventId"],
                        "properties": {
                            "eventId": { "type": "string" },
                            "delay": { "enum": ["immediate", "next_period", "next_day"] },
                            "probability": { "type": "number", "minimum": 0, "maximum": 1 }
                        }
                    }
                },
                "specialOutcome": {
                    "type": "object",
                    "properties": {
                        "type": { "enum": ["game_over", "ending_trigger", "achievement", "story_branch"] },
                        "value": { "type": "string" }
                    }
                },
                "feedback": {
                    "type": "object",
                    "properties": {
                        "text": { "type": "string" },
                        "animation": { "type": "string" },
                        "sound": { "type": "string" }
                    }
                }
            }
        }
    }
}
```

### 3.4 结局数据JSON规范

#### 3.4.1 结局列表JSON Schema
```json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "Ending Schema",
    "type": "object",
    "required": ["id", "title", "description", "category", "unlockConditions"],
    "properties": {
        "id": { "type": "string" },
        "title": {
            "type": "string",
            "minLength": 1,
            "maxLength": 30
        },
        "description": {
            "type": "string",
            "minLength": 10,
            "maxLength": 300
        },
        "category": {
            "enum": ["perfect", "good", "normal", "bad", "secret"]
        },
        "unlockConditions": {
            "type": "array",
            "minItems": 1,
            "items": {
                "type": "object",
                "required": ["conditions", "priority"],
                "properties": {
                    "conditions": {
                        "type": "array",
                        "minItems": 1,
                        "items": {
                            "type": "object",
                            "required": ["type"],
                            "properties": {
                                "type": { "enum": ["attribute", "event_triggered", "flag_set", "combination"] },
                                "attribute": { "type": "string" },
                                "operator": { "enum": [">", "<", ">=", "<=", "==", "!="] },
                                "value": {},
                                "eventId": { "type": "string" },
                                "choiceIndex": { "type": "number" },
                                "flagName": { "type": "string" },
                                "flagValue": {},
                                "conditions": { "type": "array" }
                            }
                        }
                    },
                    "priority": { "type": "number", "minimum": 0 }
                }
            }
        },
        "score": {
            "type": "object",
            "properties": {
                "base": { "type": "number", "minimum": 0 },
                "modifiers": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "condition": { "type": "object" },
                            "value": { "type": "number" }
                        }
                    }
                }
            }
        },
        "assets": {
            "type": "object",
            "properties": {
                "background": { "type": "string" },
                "achievement": { "type": "string" },
                "music": { "type": "string" }
            }
        },
        "hidden": { "type": "boolean", "default": false },
        "unlockHint": { "type": "string" }
    }
}
```

### 3.5 游戏配置JSON规范

#### 3.5.1 游戏主配置 (game_config.json)
```json
{
    "version": "1.0.0",
    "gameSettings": {
        "totalDays": 9,
        "periodsPerDay": 3,
        "periodNames": ["早上", "中午", "晚上"],
        "dayNames": [
            "腊月二十九",
            "除夕",
            "初一",
            "初二",
            "初三",
            "初四",
            "初五",
            "初六",
            "初七"
        ]
    },
    "attributeSettings": {
        "bounds": {
            "money": { "min": -50000, "max": 100000 },
            "weight": { "min": 30, "max": 200 },
            "face": { "min": 0, "max": 100 },
            "mood": { "min": 0, "max": 100 },
            "health": { "min": 0, "max": 100 },
            "luck": { "min": 0, "max": 100 }
        },
        "initialRanges": {
            "money": { "min": 0, "max": 50000 },
            "weight": { "min": 40, "max": 120 },
            "face": { "min": 20, "max": 80 },
            "mood": { "min": 30, "max": 70 },
            "health": { "min": 40, "max": 90 },
            "luck": { "min": 30, "max": 70 }
        }
    },
    "eventSettings": {
        "maxOptionsPerEvent": 4,
        "defaultEventWeight": 100,
        "specialDays": {
            "2": { "name": "除夕", "specialEvents": ["new_year_eve_dinner", "fireworks"] },
            "3": { "name": "初一", "specialEvents": ["new_year_visit", "temple_fair"] }
        }
    },
    "saveSettings": {
        "maxSaveSlots": 5,
        "autoSaveInterval": 300,
        "compressSaveData": true
    }
}
```

### 3.6 数据验证规则

#### 3.6.1 验证器接口
```typescript
interface DataValidator {
    // 验证角色数据
    validateCharacter(character: any): ValidationResult;
    
    // 验证事件数据
    validateEvent(event: any): ValidationResult;
    
    // 验证结局数据
    validateEnding(ending: any): ValidationResult;
    
    // 验证游戏状态
    validateGameState(state: any): ValidationResult;
    
    // 验证完整数据集
    validateAllData(data: GameDataSet): ValidationResult;
}

interface ValidationResult {
    valid: boolean;
    errors: ValidationError[];
    warnings: ValidationWarning[];
}

interface ValidationError {
    type: 'required' | 'type' | 'range' | 'format' | 'reference' | 'logic';
    field: string;
    message: string;
    value?: any;
}

interface ValidationWarning {
    type: 'unused' | 'duplicate' | 'balance' | 'localization';
    field: string;
    message: string;
}
```

#### 3.6.2 核心验证规则
```javascript
const VALIDATION_RULES = {
    // ID格式验证
    idFormat: /^[a-z][a-z0-9_]*$/,
    
    // 属性范围验证
    attributeValidation: {
        money: (v) => v >= -50000 && v <= 100000,
        weight: (v) => v >= 30 && v <= 200,
        face: (v) => v >= 0 && v <= 100,
        mood: (v) => v >= 0 && v <= 100,
        health: (v) => v >= 0 && v <= 100,
        luck: (v) => v >= 0 && v <= 100
    },
    
    // 事件验证
    eventValidation: {
        minOptions: 1,
        maxOptions: 4,
        maxDescriptionLength: 500,
        maxOptionTextLength: 100
    },
    
    // 引用验证
    referenceValidation: {
        checkEventReferences: true,
        checkCharacterReferences: true,
        checkItemReferences: true
    }
};
```

---


## 4. 游戏核心机制

### 4.1 事件触发机制

#### 4.1.1 触发器系统架构
```typescript
interface EventTriggerSystem {
    // 事件池管理
    eventPool: Map<string, Event>;
    triggeredEvents: Set<string>;
    pendingEvents: PriorityQueue<PendingEvent>;
    
    // 触发方法
    triggerEvent(eventId: string): TriggerResult;
    selectNextEvent(): string | null;
    
    // 条件检查
    checkConditions(conditions: Condition[]): boolean;
    checkTimeCondition(condition: TimeCondition): boolean;
    checkAttributeCondition(condition: AttributeCondition): boolean;
    checkProbabilityCondition(condition: ProbabilityCondition): boolean;
    checkEventHistoryCondition(condition: EventHistoryCondition): boolean;
}

interface TriggerResult {
    success: boolean;
    event?: Event;
    reason?: string;
}
```

#### 4.1.2 事件选择算法
```javascript
/**
 * 事件选择主算法
 * 流程：强制事件 → 待触发队列 → 随机事件池
 */
function selectNextEvent(gameState, eventPool) {
    const { currentDay, currentPeriod } = gameState.progress;
    
    // 1. 检查强制事件（时间/剧情锁定）
    const mandatoryEvent = findMandatoryEvent(currentDay, currentPeriod, eventPool);
    if (mandatoryEvent) {
        return mandatoryEvent;
    }
    
    // 2. 检查待触发队列
    const pendingEvent = findPendingEvent(gameState);
    if (pendingEvent) {
        return pendingEvent;
    }
    
    // 3. 从随机事件池选择
    return selectRandomEvent(gameState, eventPool);
}

/**
 * 查找强制事件
 */
function findMandatoryEvent(day, period, eventPool) {
    return Object.values(eventPool).find(event => {
        return event.triggerConditions.some(cond => 
            cond.type === 'time' &&
            cond.params.days?.includes(day) &&
            cond.params.periods?.includes(period) &&
            cond.params.mandatory === true
        );
    });
}

/**
 * 从随机事件池选择
 * 使用加权随机算法
 */
function selectRandomEvent(gameState, eventPool) {
    const availableEvents = filterAvailableEvents(gameState, eventPool);
    
    if (availableEvents.length === 0) {
        return getDefaultEvent();
    }
    
    // 计算权重
    const weightedEvents = availableEvents.map(event => ({
        event,
        weight: calculateEventWeight(event, gameState)
    }));
    
    // 加权随机选择
    return weightedRandomSelect(weightedEvents);
}

/**
 * 过滤可用事件
 */
function filterAvailableEvents(gameState, eventPool) {
    return Object.values(eventPool).filter(event => {
        // 检查是否已触发（一次性事件）
        if (event.onceOnly && gameState.triggeredOnceEvents.includes(event.id)) {
            return false;
        }
        
        // 检查互斥事件
        if (event.mutuallyExclusive?.some(id => 
            gameState.triggeredOnceEvents.includes(id)
        )) {
            return false;
        }
        
        // 检查前置事件
        if (event.prerequisiteEvents?.some(id => 
            !gameState.triggeredOnceEvents.includes(id)
        )) {
            return false;
        }
        
        // 检查角色限制
        if (event.exclusiveTo && 
            !event.exclusiveTo.includes(gameState.character.id)) {
            return false;
        }
        
        // 检查触发条件
        return checkTriggerConditions(event.triggerConditions, gameState);
    });
}

/**
 * 计算事件权重
 */
function calculateEventWeight(event, gameState) {
    let weight = event.weight || 100;
    
    // 运气影响
    const luck = gameState.attributes.luck;
    if (event.category === 'random') {
        // 好运增加好随机事件概率
        weight *= (0.8 + luck / 100 * 0.4);
    }
    
    // 角色特性影响
    const character = gameState.character;
    character.traits.forEach(trait => {
        if (trait.effect.type === 'event_probability' && 
            trait.effect.eventType === event.category) {
            weight *= trait.effect.multiplier;
        }
    });
    
    return Math.max(0, weight);
}

/**
 * 加权随机选择
 */
function weightedRandomSelect(weightedItems) {
    const totalWeight = weightedItems.reduce((sum, item) => sum + item.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const item of weightedItems) {
        random -= item.weight;
        if (random <= 0) {
            return item.event;
        }
    }
    
    return weightedItems[weightedItems.length - 1]?.event;
}
```

#### 4.1.3 条件检查系统
```javascript
/**
 * 条件检查主函数
 */
function checkConditions(conditions, gameState) {
    if (!conditions || conditions.length === 0) {
        return true;
    }
    
    // 所有条件必须满足（AND逻辑）
    return conditions.every(condition => checkSingleCondition(condition, gameState));
}

/**
 * 检查单个条件
 */
function checkSingleCondition(condition, gameState) {
    switch (condition.type) {
        case 'time':
            return checkTimeCondition(condition, gameState);
        case 'attribute':
            return checkAttributeCondition(condition, gameState);
        case 'probability':
            return checkProbabilityCondition(condition, gameState);
        case 'event_history':
            return checkEventHistoryCondition(condition, gameState);
        case 'character':
            return checkCharacterCondition(condition, gameState);
        case 'item':
            return checkItemCondition(condition, gameState);
        case 'flag':
            return checkFlagCondition(condition, gameState);
        default:
            console.warn(`Unknown condition type: ${condition.type}`);
            return false;
    }
}

/**
 * 时间条件检查
 */
function checkTimeCondition(condition, gameState) {
    const { currentDay, currentPeriod } = gameState.progress;
    const params = condition.params;
    
    // 检查天数
    if (params.days && !params.days.includes(currentDay)) {
        return false;
    }
    
    // 检查时段
    if (params.periods && !params.periods.includes(currentPeriod)) {
        return false;
    }
    
    // 检查天数范围
    if (params.dayRange) {
        if (currentDay < params.dayRange.min || currentDay > params.dayRange.max) {
            return false;
        }
    }
    
    return true;
}

/**
 * 属性条件检查
 */
function checkAttributeCondition(condition, gameState) {
    const { attribute, operator, value } = condition.params;
    const actualValue = gameState.attributes[attribute];
    
    switch (operator) {
        case '>': return actualValue > value;
        case '<': return actualValue < value;
        case '>=': return actualValue >= value;
        case '<=': return actualValue <= value;
        case '==': return actualValue === value;
        case '!=': return actualValue !== value;
        default: return false;
    }
}

/**
 * 概率条件检查
 */
function checkProbabilityCondition(condition, gameState) {
    const { baseRate, luckModifier = false } = condition.params;
    
    let finalRate = baseRate;
    
    // 运气修正
    if (luckModifier) {
        const luck = gameState.attributes.luck;
        // 运气50为基准，每点运气影响0.5%概率
        finalRate += (luck - 50) * 0.005;
    }
    
    // 确保概率在0-1范围内
    finalRate = Math.max(0, Math.min(1, finalRate));
    
    return Math.random() < finalRate;
}

/**
 * 事件历史条件检查
 */
function checkEventHistoryCondition(condition, gameState) {
    const { eventId, triggered, choiceIndex } = condition.params;
    
    const eventRecord = gameState.eventHistory.find(
        record => record.eventId === eventId
    );
    
    // 检查是否触发
    if (triggered !== undefined) {
        const wasTriggered = eventRecord !== undefined;
        if (wasTriggered !== triggered) {
            return false;
        }
    }
    
    // 检查选择
    if (choiceIndex !== undefined && eventRecord) {
        if (eventRecord.choiceIndex !== choiceIndex) {
            return false;
        }
    }
    
    return true;
}
```

### 4.2 属性计算公式

#### 4.2.1 属性计算系统
```typescript
interface AttributeCalculator {
    // 基础属性计算
    calculateBaseValue(attribute: string, gameState: GameState): number;
    
    // 应用效果
    applyEffect(effect: Effect, gameState: GameState): EffectResult;
    
    // 批量应用效果
    applyEffects(effects: Effect[], gameState: GameState): EffectResult[];
    
    // 属性边界检查
    clampAttribute(attribute: string, value: number): number;
    
    // 获取属性边界
    getAttributeBounds(attribute: string): { min: number; max: number };
}

interface EffectResult {
    attribute: string;
    oldValue: number;
    newValue: number;
    delta: number;
    clamped: boolean;
}
```

#### 4.2.2 属性计算公式
```javascript
/**
 * 属性计算公式系统
 */
const AttributeFormulas = {
    /**
     * 应用属性效果
     */
    applyAttributeEffect(effect, currentValue, gameState) {
        const { attribute, value, operation = 'add' } = effect;
        
        // 解析值（支持动态值）
        const resolvedValue = resolveValue(value, gameState);
        
        let newValue;
        switch (operation) {
            case 'add':
                newValue = currentValue + resolvedValue;
                break;
            case 'set':
                newValue = resolvedValue;
                break;
            case 'multiply':
                newValue = currentValue * resolvedValue;
                break;
            default:
                newValue = currentValue + resolvedValue;
        }
        
        // 应用边界
        return clampAttribute(attribute, newValue);
    },
    
    /**
     * 解析值（支持多种格式）
     */
    resolveValue(value, gameState) {
        // 数字直接返回
        if (typeof value === 'number') {
            return value;
        }
        
        // 范围随机值
        if (value && typeof value === 'object' && 'min' in value && 'max' in value) {
            return randomRange(value.min, value.max);
        }
        
        // 基于属性的动态值
        if (value && typeof value === 'object' && 'attribute' in value) {
            const baseValue = gameState.attributes[value.attribute];
            const multiplier = value.multiplier || 1;
            return baseValue * multiplier;
        }
        
        // 公式表达式
        if (value && typeof value === 'object' && 'formula' in value) {
            return evaluateFormula(value.formula, gameState);
        }
        
        return 0;
    },
    
    /**
     * 属性边界限制
     */
    clampAttribute(attribute, value) {
        const bounds = ATTRIBUTE_BOUNDS[attribute];
        if (!bounds) return value;
        
        return Math.max(bounds.min, Math.min(bounds.max, value));
    },
    
    /**
     * 计算运气影响
     * 用于随机事件的额外修正
     */
    calculateLuckEffect(baseValue, luck, effectType = 'neutral') {
        const luckDeviation = luck - 50; // -50 到 50
        
        switch (effectType) {
            case 'positive':
                // 好运增强正面效果
                return baseValue * (1 + luckDeviation * 0.01);
            case 'negative':
                // 好运减轻负面效果
                return baseValue * (1 - luckDeviation * 0.005);
            case 'neutral':
            default:
                return baseValue;
        }
    },
    
    /**
     * 计算复合属性
     */
    calculateCompositeAttribute(gameState) {
        const { money, face, mood, health } = gameState.attributes;
        
        // 综合幸福指数
        const happiness = (
            mood * 0.3 +
            face * 0.25 +
            Math.min(health, 100) * 0.25 +
            Math.min(money / 1000, 100) * 0.2
        );
        
        // 生存压力指数
        const pressure = Math.max(0, 
            100 - mood * 0.4 - health * 0.3 - (money > 0 ? 20 : 0)
        );
        
        return { happiness, pressure };
    }
};

/**
 * 辅助函数
 */
function randomRange(min, max) {
    return min + Math.random() * (max - min);
}

function evaluateFormula(formula, gameState) {
    // 安全公式求值
    // 只支持基本运算符和属性引用
    const safeFormula = formula.replace(/([a-z_]+)/g, (match) => {
        if (gameState.attributes[match] !== undefined) {
            return gameState.attributes[match];
        }
        return match;
    });
    
    try {
        return Function('"use strict"; return (' + safeFormula + ')')();
    } catch (e) {
        console.error('Formula evaluation error:', e);
        return 0;
    }
}
```

#### 4.2.3 属性联动效果
```javascript
/**
 * 属性联动系统
 * 某些属性变化会触发其他属性的连锁反应
 */
const AttributeLinkages = {
    // 健康与心情的联动
    healthMoodLinkage: {
        // 健康低于30时，心情每天下降
        condition: (attrs) => attrs.health < 30,
        effect: { mood: -5 },
        trigger: 'daily'
    },
    
    // 心情与运气的联动
    moodLuckLinkage: {
        // 心情影响运气波动
        calculate: (mood) => (mood - 50) * 0.1,
        apply: 'random_modifier'
    },
    
    // 体重与健康的联动
    weightHealthLinkage: {
        // 体重过高或过低影响健康
        condition: (attrs) => attrs.weight > 100 || attrs.weight < 45,
        effect: { health: -2 },
        trigger: 'daily'
    },
    
    // 存款与面子的联动
    moneyFaceLinkage: {
        // 存款为负时面子下降
        condition: (attrs) => attrs.money < 0,
        effect: { face: -3 },
        trigger: 'event'
    },
    
    /**
     * 应用联动效果
     */
    applyLinkages(gameState) {
        const linkages = [];
        
        // 检查所有联动条件
        Object.entries(this).forEach(([name, linkage]) => {
            if (typeof linkage !== 'object' || !linkage.condition) return;
            
            if (linkage.condition(gameState.attributes)) {
                linkages.push({
                    name,
                    effect: linkage.effect
                });
            }
        });
        
        return linkages;
    }
};
```

### 4.3 结局判定逻辑

#### 4.3.1 结局判定系统
```typescript
interface EndingJudgmentSystem {
    // 判定结局
    judgeEnding(gameState: GameState): EndingResult;
    
    // 检查结局条件
    checkEndingConditions(ending: Ending, gameState: GameState): boolean;
    
    // 计算结局分数
    calculateEndingScore(ending: Ending, gameState: GameState): number;
    
    // 获取所有可解锁结局
    getAvailableEndings(gameState: GameState, endingPool: Ending[]): Ending[];
}

interface EndingResult {
    ending: Ending;
    score: number;
    rank: string;
    statistics: EndingStatistics;
}
```

#### 4.3.2 结局判定算法
```javascript
/**
 * 结局判定主算法
 */
function judgeEnding(gameState, endingPool) {
    // 1. 获取所有满足条件的结局
    const availableEndings = getAvailableEndings(gameState, endingPool);
    
    if (availableEndings.length === 0) {
        // 返回默认结局
        return getDefaultEnding(gameState);
    }
    
    // 2. 按优先级排序
    availableEndings.sort((a, b) => {
        const priorityA = getEndingPriority(a, gameState);
        const priorityB = getEndingPriority(b, gameState);
        return priorityB - priorityA;
    });
    
    // 3. 选择最高优先级的结局
    const selectedEnding = availableEndings[0];
    
    // 4. 计算分数
    const score = calculateEndingScore(selectedEnding, gameState);
    
    // 5. 确定评级
    const rank = determineEndingRank(score, selectedEnding);
    
    return {
        ending: selectedEnding,
        score,
        rank,
        statistics: generateEndingStatistics(gameState)
    };
}

/**
 * 获取可用结局
 */
function getAvailableEndings(gameState, endingPool) {
    return endingPool.filter(ending => {
        // 检查所有条件组，满足任一即可
        return ending.unlockConditions.some(conditionGroup => 
            checkEndingConditionGroup(conditionGroup, gameState)
        );
    });
}

/**
 * 检查结局条件组
 */
function checkEndingConditionGroup(conditionGroup, gameState) {
    // 组内所有条件必须同时满足
    return conditionGroup.conditions.every(condition => 
        checkEndingCondition(condition, gameState)
    );
}

/**
 * 检查单个结局条件
 */
function checkEndingCondition(condition, gameState) {
    switch (condition.type) {
        case 'attribute':
            return checkAttributeEndingCondition(condition, gameState);
        case 'event_triggered':
            return checkEventEndingCondition(condition, gameState);
        case 'flag_set':
            return checkFlagEndingCondition(condition, gameState);
        case 'combination':
            return condition.conditions.every(c => 
                checkEndingCondition(c, gameState)
            );
        default:
            return false;
    }
}

/**
 * 属性结局条件检查
 */
function checkAttributeEndingCondition(condition, gameState) {
    const { attribute, operator, value } = condition;
    const actualValue = gameState.attributes[attribute];
    
    switch (operator) {
        case '>': return actualValue > value;
        case '<': return actualValue < value;
        case '>=': return actualValue >= value;
        case '<=': return actualValue <= value;
        case '==': return actualValue === value;
        case '!=': return actualValue !== value;
        default: return false;
    }
}

/**
 * 事件结局条件检查
 */
function checkEventEndingCondition(condition, gameState) {
    const { eventId, choiceIndex } = condition;
    
    const eventRecord = gameState.eventHistory.find(
        record => record.eventId === eventId
    );
    
    if (!eventRecord) return false;
    
    if (choiceIndex !== undefined) {
        return eventRecord.choiceIndex === choiceIndex;
    }
    
    return true;
}

/**
 * 标记结局条件检查
 */
function checkFlagEndingCondition(condition, gameState) {
    const { flagName, flagValue } = condition;
    const actualValue = gameState.flags[flagName];
    
    return actualValue === flagValue;
}

/**
 * 获取结局优先级
 */
function getEndingPriority(ending, gameState) {
    // 找到满足的条件组，返回其优先级
    for (const conditionGroup of ending.unlockConditions) {
        if (checkEndingConditionGroup(conditionGroup, gameState)) {
            return conditionGroup.priority;
        }
    }
    return 0;
}

/**
 * 计算结局分数
 */
function calculateEndingScore(ending, gameState) {
    let score = ending.score?.base || 0;
    
    // 应用分数修正
    if (ending.score?.modifiers) {
        for (const modifier of ending.score.modifiers) {
            if (checkEndingCondition(modifier.condition, gameState)) {
                score += modifier.value;
            }
        }
    }
    
    // 根据最终属性计算额外分数
    const { money, face, mood, health, luck } = gameState.attributes;
    score += money / 1000 * 5;      // 存款每1000元+5分
    score += face * 2;               // 面子每点+2分
    score += mood * 2;               // 心情每点+2分
    score += health * 1.5;           // 健康每点+1.5分
    score += luck;                   // 运气每点+1分
    
    return Math.round(score);
}

/**
 * 确定结局评级
 */
function determineEndingRank(score, ending) {
    const category = ending.category;
    
    // 根据结局类别和分数确定评级
    const rankThresholds = {
        perfect: { S: 2000, A: 1500, B: 1000 },
        good: { S: 1500, A: 1000, B: 600 },
        normal: { S: 1000, A: 700, B: 400 },
        bad: { S: 500, A: 300, B: 100 },
        secret: { S: 2000, A: 1500, B: 1000 }
    };
    
    const thresholds = rankThresholds[category] || rankThresholds.normal;
    
    if (score >= thresholds.S) return 'S';
    if (score >= thresholds.A) return 'A';
    if (score >= thresholds.B) return 'B';
    return 'C';
}

/**
 * 生成结局统计
 */
function generateEndingStatistics(gameState) {
    const stats = gameState.statistics;
    
    return {
        totalEvents: stats.totalEvents,
        totalChoices: stats.totalChoices,
        moneyChange: stats.moneyEarned - stats.moneySpent,
        redEnvelopesNet: stats.redEnvelopesReceived - stats.redEnvelopesGiven,
        finalAttributes: { ...gameState.attributes },
        playTime: Date.now() - gameState.meta.startTime
    };
}
```

#### 4.3.3 结局判定流程图
```
┌─────────────────────────────────────────────────────────────┐
│                    结局判定流程                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 1. 检查游戏是否结束（第9天晚时段结束）                       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. 遍历所有结局，筛选满足条件的结局                          │
│    - 检查每个结局的unlockConditions                          │
│    - 任一条件组满足即可                                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. 按优先级排序可用结局                                      │
│    - 优先选择高优先级的结局                                  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. 选择最高优先级的结局                                      │
│    - 同优先级时选择第一个                                    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. 计算结局分数                                              │
│    - 基础分数 + 修正分数 + 属性加成                          │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. 确定结局评级（S/A/B/C）                                   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. 生成结局统计并展示                                        │
└─────────────────────────────────────────────────────────────┘
```

---


## 5. 存档系统

### 5.1 存档系统架构

#### 5.1.1 系统概述
```
┌─────────────────────────────────────────────────────────────────┐
│                      存档系统架构                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐      │
│  │   游戏状态    │───▶│  存档管理器   │───▶│  存储介质     │      │
│  │  GameState   │    │ SaveManager  │    │ (localStorage)│      │
│  └──────────────┘    └──────────────┘    └──────────────┘      │
│                              │                                   │
│                              ▼                                   │
│                       ┌──────────────┐                          │
│                       │  存档数据     │                          │
│                       │  SaveData    │                          │
│                       └──────────────┘                          │
│                              │                                   │
│                    ┌─────────┴─────────┐                        │
│                    ▼                   ▼                        │
│            ┌──────────────┐   ┌──────────────┐                 │
│            │  自动存档     │   │  手动存档     │                 │
│            │ Auto Save    │   │Manual Save   │                 │
│            └──────────────┘   └──────────────┘                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

#### 5.1.2 存档管理器接口
```typescript
interface SaveManager {
    // 存档槽位数量
    readonly maxSlots: number;
    
    // 自动存档间隔（秒）
    readonly autoSaveInterval: number;
    
    // 初始化
    initialize(): Promise<void>;
    
    // 创建新存档
    createSave(gameState: GameState, slot?: number, metadata?: SaveMetadata): Promise<SaveResult>;
    
    // 加载存档
    loadSave(slot: number): Promise<GameState>;
    
    // 删除存档
    deleteSave(slot: number): Promise<boolean>;
    
    // 获取存档列表
    getSaveList(): Promise<SaveInfo[]>;
    
    // 自动存档
    autoSave(gameState: GameState): Promise<void>;
    
    // 导出存档（为分享/备份）
    exportSave(slot: number): Promise<string>;
    
    // 导入存档
    importSave(saveData: string, slot?: number): Promise<SaveResult>;
    
    // 检查存档完整性
    verifySave(slot: number): Promise<VerificationResult>;
}

interface SaveMetadata {
    name?: string;
    description?: string;
    thumbnail?: string;
}

interface SaveInfo {
    slot: number;
    exists: boolean;
    timestamp: number;
    day: number;
    period: number;
    characterName: string;
    playTime: number;
    metadata?: SaveMetadata;
}

interface SaveResult {
    success: boolean;
    slot: number;
    timestamp: number;
    error?: string;
}

interface VerificationResult {
    valid: boolean;
    errors: string[];
    warnings: string[];
}
```

### 5.2 存档数据结构

#### 5.2.1 完整存档数据结构
```typescript
interface SaveData {
    // 存档元信息
    meta: {
        version: string;           // 存档格式版本
        gameVersion: string;       // 游戏版本
        createdAt: number;         // 创建时间戳
        updatedAt: number;         // 更新时间戳
        slot: number;              // 存档槽位
        checksum: string;          // 数据校验和
    };
    
    // 存档元数据（用户自定义）
    metadata: {
        name: string;              // 存档名称
        description: string;       // 存档描述
        thumbnail?: string;        // 缩略图（Base64）
    };
    
    // 游戏状态（核心数据）
    gameState: {
        // 进度信息
        progress: {
            currentDay: number;
            currentPeriod: number;
            totalPeriods: number;
        };
        
        // 角色信息
        character: {
            id: string;
            name: string;
        };
        
        // 属性值
        attributes: {
            money: number;
            weight: number;
            face: number;
            mood: number;
            health: number;
            luck: number;
        };
        
        // 物品栏
        inventory: {
            [itemId: string]: number;
        };
        
        // 事件历史
        eventHistory: Array<{
            eventId: string;
            day: number;
            period: number;
            choiceIndex: number;
            choiceId: string;
            timestamp: number;
        }>;
        
        // 游戏标记
        flags: {
            [flagName: string]: any;
        };
        
        // 待触发事件
        pendingEvents: Array<{
            eventId: string;
            triggerDay?: number;
            triggerPeriod?: number;
            priority: number;
        }>;
        
        // 已触发的一次性事件
        triggeredOnceEvents: string[];
        
        // 统计数据
        statistics: {
            totalEvents: number;
            totalChoices: number;
            moneySpent: number;
            moneyEarned: number;
            redEnvelopesGiven: number;
            redEnvelopesReceived: number;
            mealsEaten: number;
            relativesMet: number;
        };
        
        // 随机种子（确保可重现性）
        randomSeed: number;
        
        // 游戏开始时间
        startTime: number;
        
        // 累计游戏时间（毫秒）
        totalPlayTime: number;
    };
    
    // 系统状态
    system: {
        // 成就解锁状态
        achievements: string[];
        
        // 解锁的角色
        unlockedCharacters: string[];
        
        // 解锁的结局
        unlockedEndings: string[];
        
        // 游戏设置
        settings: {
            soundVolume: number;
            musicVolume: number;
            textSpeed: number;
            language: string;
        };
    };
}
```

#### 5.2.2 存档数据JSON示例
```json
{
    "meta": {
        "version": "1.0.0",
        "gameVersion": "1.0.0",
        "createdAt": 1704067200000,
        "updatedAt": 1704153600000,
        "slot": 1,
        "checksum": "a1b2c3d4e5f6"
    },
    "metadata": {
        "name": "程序员小王的春节",
        "description": "第5天晚上，存款还剩15000",
        "thumbnail": "data:image/png;base64,iVBORw0KG..."
    },
    "gameState": {
        "progress": {
            "currentDay": 5,
            "currentPeriod": 2,
            "totalPeriods": 14
        },
        "character": {
            "id": "programmer",
            "name": "程序员小王"
        },
        "attributes": {
            "money": 15000,
            "weight": 73,
            "face": 65,
            "mood": 55,
            "health": 60,
            "luck": 45
        },
        "inventory": {
            "red_envelope": 3,
            "health_product": 1
        },
        "eventHistory": [
            {
                "eventId": "new_year_eve_dinner",
                "day": 2,
                "period": 1,
                "choiceIndex": 0,
                "choiceId": "eat_more",
                "timestamp": 1704067200000
            },
            {
                "eventId": "relative_question",
                "day": 3,
                "period": 0,
                "choiceIndex": 1,
                "choiceId": "polite_answer",
                "timestamp": 1704099600000
            }
        ],
        "flags": {
            "met_uncle_wang": true,
            "received_lucky_money": 2000,
            "family_harmony": 75
        },
        "pendingEvents": [],
        "triggeredOnceEvents": ["new_year_eve_dinner", "new_year_visit"],
        "statistics": {
            "totalEvents": 14,
            "totalChoices": 14,
            "moneySpent": 15000,
            "moneyEarned": 2000,
            "redEnvelopesGiven": 5,
            "redEnvelopesReceived": 3,
            "mealsEaten": 12,
            "relativesMet": 8
        },
        "randomSeed": 123456789,
        "startTime": 1704067200000,
        "totalPlayTime": 3600000
    },
    "system": {
        "achievements": ["first_play", "survive_5_days"],
        "unlockedCharacters": ["programmer", "teacher", "student"],
        "unlockedEndings": [],
        "settings": {
            "soundVolume": 0.8,
            "musicVolume": 0.6,
            "textSpeed": 1.0,
            "language": "zh-CN"
        }
    }
}
```

### 5.3 存档/读取逻辑

#### 5.3.1 存档管理器实现
```javascript
/**
 * 存档管理器类
 */
class SaveManagerImpl {
    constructor(config = {}) {
        this.maxSlots = config.maxSlots || 5;
        this.autoSaveInterval = config.autoSaveInterval || 300;
        this.storageKey = 'spring_festival_simulator_saves';
        this.version = '1.0.0';
    }
    
    /**
     * 初始化存档系统
     */
    async initialize() {
        // 检查存储空间
        const available = await this.checkStorageSpace();
        if (!available) {
            throw new Error('存储空间不足');
        }
        
        // 迁移旧版本存档
        await this.migrateOldSaves();
        
        console.log('存档系统初始化完成');
    }
    
    /**
     * 创建新存档
     */
    async createSave(gameState, slot = null, metadata = {}) {
        try {
            // 确定存档槽位
            const targetSlot = slot ?? await this.findEmptySlot();
            if (targetSlot === null) {
                return {
                    success: false,
                    error: '存档槽位已满'
                };
            }
            
            // 构建存档数据
            const saveData = this.buildSaveData(gameState, targetSlot, metadata);
            
            // 计算校验和
            saveData.meta.checksum = this.calculateChecksum(saveData);
            
            // 序列化
            const serialized = this.serialize(saveData);
            
            // 存储
            await this.saveToStorage(targetSlot, serialized);
            
            return {
                success: true,
                slot: targetSlot,
                timestamp: saveData.meta.updatedAt
            };
        } catch (error) {
            console.error('存档失败:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * 加载存档
     */
    async loadSave(slot) {
        try {
            // 从存储读取
            const serialized = await this.loadFromStorage(slot);
            if (!serialized) {
                throw new Error(`存档槽位 ${slot} 不存在`);
            }
            
            // 反序列化
            const saveData = this.deserialize(serialized);
            
            // 验证存档
            const verification = this.verifySaveData(saveData);
            if (!verification.valid) {
                throw new Error(`存档验证失败: ${verification.errors.join(', ')}`);
            }
            
            // 版本检查
            if (saveData.meta.version !== this.version) {
                saveData = await this.migrateSaveData(saveData);
            }
            
            // 恢复游戏状态
            return this.restoreGameState(saveData);
        } catch (error) {
            console.error('读档失败:', error);
            throw error;
        }
    }
    
    /**
     * 删除存档
     */
    async deleteSave(slot) {
        try {
            await this.removeFromStorage(slot);
            return true;
        } catch (error) {
            console.error('删除存档失败:', error);
            return false;
        }
    }
    
    /**
     * 获取存档列表
     */
    async getSaveList() {
        const saves = [];
        
        for (let slot = 1; slot <= this.maxSlots; slot++) {
            const saveInfo = await this.getSaveInfo(slot);
            saves.push(saveInfo);
        }
        
        return saves;
    }
    
    /**
     * 自动存档
     */
    async autoSave(gameState) {
        // 使用专用自动存档槽位（0）
        return await this.createSave(gameState, 0, {
            name: '自动存档',
            description: `第${gameState.progress.currentDay}天 ${this.getPeriodName(gameState.progress.currentPeriod)}`
        });
    }
    
    /**
     * 导出存档
     */
    async exportSave(slot) {
        const serialized = await this.loadFromStorage(slot);
        if (!serialized) {
            throw new Error('存档不存在');
        }
        
        // 压缩并编码
        const compressed = await this.compress(serialized);
        const encoded = btoa(compressed);
        
        return encoded;
    }
    
    /**
     * 导入存档
     */
    async importSave(saveData, slot = null) {
        try {
            // 解码并解压
            const decoded = atob(saveData);
            const decompressed = await this.decompress(decoded);
            
            // 解析
            const parsed = JSON.parse(decompressed);
            
            // 验证
            const verification = this.verifySaveData(parsed);
            if (!verification.valid) {
                throw new Error('存档数据无效');
            }
            
            // 保存到新槽位
            const targetSlot = slot ?? await this.findEmptySlot();
            parsed.meta.slot = targetSlot;
            parsed.meta.updatedAt = Date.now();
            
            await this.saveToStorage(targetSlot, JSON.stringify(parsed));
            
            return {
                success: true,
                slot: targetSlot
            };
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    /**
     * 验证存档
     */
    async verifySave(slot) {
        const serialized = await this.loadFromStorage(slot);
        if (!serialized) {
            return { valid: false, errors: ['存档不存在'], warnings: [] };
        }
        
        try {
            const saveData = this.deserialize(serialized);
            return this.verifySaveData(saveData);
        } catch (error) {
            return { valid: false, errors: [error.message], warnings: [] };
        }
    }
    
    // ============ 私有方法 ============
    
    /**
     * 构建存档数据
     */
    buildSaveData(gameState, slot, metadata) {
        const now = Date.now();
        
        return {
            meta: {
                version: this.version,
                gameVersion: '1.0.0',
                createdAt: gameState.meta?.startTime || now,
                updatedAt: now,
                slot: slot,
                checksum: ''
            },
            metadata: {
                name: metadata.name || `存档 ${slot}`,
                description: metadata.description || '',
                thumbnail: metadata.thumbnail
            },
            gameState: {
                progress: { ...gameState.progress },
                character: { ...gameState.character },
                attributes: { ...gameState.attributes },
                inventory: { ...gameState.inventory },
                eventHistory: [...gameState.eventHistory],
                flags: { ...gameState.flags },
                pendingEvents: [...gameState.pendingEvents],
                triggeredOnceEvents: [...gameState.triggeredOnceEvents],
                statistics: { ...gameState.statistics },
                randomSeed: gameState.randomSeed,
                startTime: gameState.meta?.startTime || now,
                totalPlayTime: this.calculatePlayTime(gameState)
            },
            system: {
                achievements: [...(gameState.system?.achievements || [])],
                unlockedCharacters: [...(gameState.system?.unlockedCharacters || [])],
                unlockedEndings: [...(gameState.system?.unlockedEndings || [])],
                settings: { ...(gameState.system?.settings || this.getDefaultSettings()) }
            }
        };
    }
    
    /**
     * 恢复游戏状态
     */
    restoreGameState(saveData) {
        return {
            meta: {
                version: saveData.meta.gameVersion,
                startTime: saveData.gameState.startTime,
                lastSaveTime: saveData.meta.updatedAt,
                playCount: 1
            },
            progress: { ...saveData.gameState.progress },
            character: { ...saveData.gameState.character },
            attributes: { ...saveData.gameState.attributes },
            inventory: { ...saveData.gameState.inventory },
            eventHistory: [...saveData.gameState.eventHistory],
            flags: { ...saveData.gameState.flags },
            pendingEvents: [...saveData.gameState.pendingEvents],
            triggeredOnceEvents: [...saveData.gameState.triggeredOnceEvents],
            statistics: { ...saveData.gameState.statistics },
            randomSeed: saveData.gameState.randomSeed,
            system: { ...saveData.system }
        };
    }
    
    /**
     * 验证存档数据
     */
    verifySaveData(saveData) {
        const errors = [];
        const warnings = [];
        
        // 检查必要字段
        const requiredFields = ['meta', 'gameState'];
        for (const field of requiredFields) {
            if (!saveData[field]) {
                errors.push(`缺少必要字段: ${field}`);
            }
        }
        
        // 检查版本
        if (saveData.meta?.version && saveData.meta.version !== this.version) {
            warnings.push(`存档版本 ${saveData.meta.version} 与当前版本 ${this.version} 不匹配`);
        }
        
        // 检查校验和
        if (saveData.meta?.checksum) {
            const calculated = this.calculateChecksum(saveData);
            if (calculated !== saveData.meta.checksum) {
                errors.push('存档数据校验失败，可能已损坏');
            }
        }
        
        // 检查属性范围
        if (saveData.gameState?.attributes) {
            const attrs = saveData.gameState.attributes;
            for (const [key, value] of Object.entries(attrs)) {
                const bounds = ATTRIBUTE_BOUNDS[key];
                if (bounds && (value < bounds.min || value > bounds.max)) {
                    warnings.push(`属性 ${key} 的值 ${value} 超出正常范围`);
                }
            }
        }
        
        return {
            valid: errors.length === 0,
            errors,
            warnings
        };
    }
    
    /**
     * 计算校验和
     */
    calculateChecksum(saveData) {
        // 使用简单的字符串哈希
        const dataStr = JSON.stringify({
            gameState: saveData.gameState,
            system: saveData.system
        });
        
        let hash = 0;
        for (let i = 0; i < dataStr.length; i++) {
            const char = dataStr.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        
        return hash.toString(16);
    }
    
    /**
     * 序列化
     */
    serialize(saveData) {
        return JSON.stringify(saveData);
    }
    
    /**
     * 反序列化
     */
    deserialize(serialized) {
        return JSON.parse(serialized);
    }
    
    /**
     * 存储到 localStorage
     */
    async saveToStorage(slot, data) {
        const key = `${this.storageKey}_${slot}`;
        localStorage.setItem(key, data);
    }
    
    /**
     * 从 localStorage 读取
     */
    async loadFromStorage(slot) {
        const key = `${this.storageKey}_${slot}`;
        return localStorage.getItem(key);
    }
    
    /**
     * 从 localStorage 删除
     */
    async removeFromStorage(slot) {
        const key = `${this.storageKey}_${slot}`;
        localStorage.removeItem(key);
    }
    
    /**
     * 查找空槽位
     */
    async findEmptySlot() {
        for (let slot = 1; slot <= this.maxSlots; slot++) {
            const exists = await this.loadFromStorage(slot);
            if (!exists) {
                return slot;
            }
        }
        return null;
    }
    
    /**
     * 获取存档信息
     */
    async getSaveInfo(slot) {
        const serialized = await this.loadFromStorage(slot);
        
        if (!serialized) {
            return {
                slot,
                exists: false,
                timestamp: 0,
                day: 0,
                period: 0,
                characterName: '',
                playTime: 0
            };
        }
        
        try {
            const saveData = this.deserialize(serialized);
            return {
                slot,
                exists: true,
                timestamp: saveData.meta.updatedAt,
                day: saveData.gameState.progress.currentDay,
                period: saveData.gameState.progress.currentPeriod,
                characterName: saveData.gameState.character.name,
                playTime: saveData.gameState.totalPlayTime,
                metadata: saveData.metadata
            };
        } catch (error) {
            return {
                slot,
                exists: true,
                timestamp: 0,
                day: 0,
                period: 0,
                characterName: '损坏的存档',
                playTime: 0,
                corrupted: true
            };
        }
    }
    
    /**
     * 检查存储空间
     */
    async checkStorageSpace() {
        try {
            const testKey = `${this.storageKey}_test`;
            localStorage.setItem(testKey, 'test');
            localStorage.removeItem(testKey);
            return true;
        } catch (e) {
            return false;
        }
    }
    
    /**
     * 计算游戏时间
     */
    calculatePlayTime(gameState) {
        const startTime = gameState.meta?.startTime || Date.now();
        return Date.now() - startTime;
    }
    
    /**
     * 获取时段名称
     */
    getPeriodName(period) {
        const names = ['早上', '中午', '晚上'];
        return names[period] || '未知';
    }
    
    /**
     * 获取默认设置
     */
    getDefaultSettings() {
        return {
            soundVolume: 0.8,
            musicVolume: 0.6,
            textSpeed: 1.0,
            language: 'zh-CN'
        };
    }
}
```

#### 5.3.2 存档自动保存机制
```javascript
/**
 * 自动存档管理器
 */
class AutoSaveManager {
    constructor(saveManager, interval = 300) {
        this.saveManager = saveManager;
        this.interval = interval * 1000; // 转换为毫秒
        this.timer = null;
        this.lastSaveTime = 0;
        this.isEnabled = true;
    }
    
    /**
     * 启动自动存档
     */
    start(gameStateProvider) {
        this.stop();
        this.gameStateProvider = gameStateProvider;
        
        this.timer = setInterval(() => {
            this.performAutoSave();
        }, this.interval);
        
        console.log('自动存档已启动');
    }
    
    /**
     * 停止自动存档
     */
    stop() {
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
            console.log('自动存档已停止');
        }
    }
    
    /**
     * 执行自动存档
     */
    async performAutoSave() {
        if (!this.isEnabled || !this.gameStateProvider) {
            return;
        }
        
        const gameState = this.gameStateProvider();
        if (!gameState) {
            return;
        }
        
        // 避免过于频繁的存档
        const now = Date.now();
        if (now - this.lastSaveTime < 60000) { // 最少间隔1分钟
            return;
        }
        
        try {
            const result = await this.saveManager.autoSave(gameState);
            if (result.success) {
                this.lastSaveTime = now;
                console.log('自动存档成功:', new Date(now).toLocaleString());
            }
        } catch (error) {
            console.error('自动存档失败:', error);
        }
    }
    
    /**
     * 触发即时存档（重要节点）
     */
    async triggerImmediateSave() {
        if (!this.gameStateProvider) {
            return;
        }
        
        const gameState = this.gameStateProvider();
        if (!gameState) {
            return;
        }
        
        try {
            const result = await this.saveManager.autoSave(gameState);
            if (result.success) {
                this.lastSaveTime = Date.now();
                console.log('即时存档成功');
            }
        } catch (error) {
            console.error('即时存档失败:', error);
        }
    }
    
    /**
     * 设置是否启用
     */
    setEnabled(enabled) {
        this.isEnabled = enabled;
    }
}
```

### 5.4 存档数据迁移

#### 5.4.1 版本迁移策略
```javascript
/**
 * 存档数据迁移器
 */
class SaveDataMigrator {
    constructor() {
        this.migrations = {
            '0.9.0': this.migrateFrom0_9_0.bind(this),
            '1.0.0': this.migrateTo1_0_0.bind(this)
        };
    }
    
    /**
     * 迁移存档数据
     */
    async migrate(saveData, targetVersion) {
        const currentVersion = saveData.meta?.version || '0.0.0';
        
        if (currentVersion === targetVersion) {
            return saveData;
        }
        
        console.log(`迁移存档: ${currentVersion} -> ${targetVersion}`);
        
        let migratedData = { ...saveData };
        
        // 按版本顺序执行迁移
        const versions = Object.keys(this.migrations).sort();
        for (const version of versions) {
            if (this.compareVersions(currentVersion, version) < 0) {
                migratedData = await this.migrations[version](migratedData);
                migratedData.meta.version = version;
            }
        }
        
        migratedData.meta.version = targetVersion;
        return migratedData;
    }
    
    /**
     * 从 0.9.0 迁移
     */
    async migrateFrom0_9_0(saveData) {
        // 添加新的属性字段
        if (!saveData.gameState.attributes.luck) {
            saveData.gameState.attributes.luck = 50;
        }
        
        // 迁移事件历史格式
        if (saveData.gameState.eventHistory) {
            saveData.gameState.eventHistory = saveData.gameState.eventHistory.map(record => ({
                ...record,
                choiceId: record.choiceId || `choice_${record.choiceIndex}`
            }));
        }
        
        return saveData;
    }
    
    /**
     * 迁移到 1.0.0
     */
    async migrateTo1_0_0(saveData) {
        // 添加系统状态
        if (!saveData.system) {
            saveData.system = {
                achievements: [],
                unlockedCharacters: [saveData.gameState.character.id],
                unlockedEndings: [],
                settings: {
                    soundVolume: 0.8,
                    musicVolume: 0.6,
                    textSpeed: 1.0,
                    language: 'zh-CN'
                }
            };
        }
        
        // 添加元数据
        if (!saveData.metadata) {
            saveData.metadata = {
                name: `存档 ${saveData.meta.slot}`,
                description: ''
            };
        }
        
        return saveData;
    }
    
    /**
     * 比较版本号
     */
    compareVersions(v1, v2) {
        const parts1 = v1.split('.').map(Number);
        const parts2 = v2.split('.').map(Number);
        
        for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
            const p1 = parts1[i] || 0;
            const p2 = parts2[i] || 0;
            
            if (p1 < p2) return -1;
            if (p1 > p2) return 1;
        }
        
        return 0;
    }
}
```

---


## 6. 附录

### 6.1 完整类型定义汇总

#### 6.1.1 核心类型定义
```typescript
// ============================================
// 游戏核心类型定义
// ============================================

// 属性类型
type AttributeType = 'money' | 'weight' | 'face' | 'mood' | 'health' | 'luck';

// 属性值对象
interface Attributes {
    money: number;
    weight: number;
    face: number;
    mood: number;
    health: number;
    luck: number;
}

// 时段类型
 type PeriodType = 0 | 1 | 2; // 早上 | 中午 | 晚上

// 事件类别
 type EventCategory = 'family' | 'social' | 'food' | 'money' | 'health' | 'random' | 'story' | 'special';

// 结局类别
 type EndingCategory = 'perfect' | 'good' | 'normal' | 'bad' | 'secret';

// 物品类别
 type ItemCategory = 'gift' | 'food' | 'medicine' | 'tool' | 'special';

// 效果操作类型
 type EffectOperation = 'add' | 'set' | 'multiply';

// 条件操作符
 type ConditionOperator = '>' | '<' | '>=' | '<=' | '==' | '!=';

// ============================================
// 角色相关类型
// ============================================

interface Character {
    id: string;
    name: string;
    description: string;
    avatar: string;
    initialAttributes: Attributes;
    traits: Trait[];
    exclusiveEvents: string[];
    unlockCondition?: UnlockCondition;
}

interface Trait {
    id: string;
    name: string;
    description: string;
    effect: TraitEffect;
}

type TraitEffect = 
    | { type: 'attribute_modifier'; attribute: string; value: number; condition?: string }
    | { type: 'event_probability'; eventType: string; multiplier: number }
    | { type: 'special_option'; eventId: string; optionId: string };

interface UnlockCondition {
    type: 'default' | 'achievement' | 'previous_play';
    requirement?: string;
}

// ============================================
// 事件相关类型
// ============================================

interface Event {
    id: string;
    title: string;
    description: string;
    category: EventCategory;
    triggerConditions: TriggerCondition[];
    mutuallyExclusive?: string[];
    prerequisiteEvents?: string[];
    unlockEvents?: string[];
    options: Option[];
    defaultOption?: Option;
    weight: number;
    onceOnly: boolean;
    exclusiveTo?: string[];
    assets: EventAssets;
}

interface EventAssets {
    background?: string;
    character?: string;
    icon?: string;
}

type TriggerCondition = 
    | TimeCondition
    | AttributeCondition
    | ProbabilityCondition
    | EventHistoryCondition
    | CharacterCondition;

interface TimeCondition {
    type: 'time';
    params: {
        days?: number[];
        periods?: number[];
        dayRange?: { min: number; max: number };
        mandatory?: boolean;
    };
}

interface AttributeCondition {
    type: 'attribute';
    params: {
        attribute: string;
        operator: ConditionOperator;
        value: number;
    };
}

interface ProbabilityCondition {
    type: 'probability';
    params: {
        baseRate: number;
        luckModifier?: boolean;
    };
}

interface EventHistoryCondition {
    type: 'event_history';
    params: {
        eventId: string;
        triggered: boolean;
        choiceIndex?: number;
    };
}

interface CharacterCondition {
    type: 'character';
    params: {
        characterIds: string[];
    };
}

// ============================================
// 选项相关类型
// ============================================

interface Option {
    id: string;
    text: string;
    visibilityConditions?: Condition[];
    availabilityConditions?: Condition[];
    unavailableText?: string;
    effects: Effect[];
    followUpEvents?: FollowUpEvent[];
    specialOutcome?: SpecialOutcome;
    feedback?: OptionFeedback;
}

interface FollowUpEvent {
    eventId: string;
    delay?: 'immediate' | 'next_period' | 'next_day';
    probability?: number;
}

interface SpecialOutcome {
    type: 'game_over' | 'ending_trigger' | 'achievement' | 'story_branch';
    value: string;
}

interface OptionFeedback {
    text: string;
    animation?: string;
    sound?: string;
}

// ============================================
// 效果相关类型
// ============================================

interface Effect {
    type: 'attribute' | 'item' | 'flag' | 'event' | 'special';
    attribute?: string;
    value?: number | RandomRange | AttributeReference | FormulaExpression;
    operation?: EffectOperation;
    itemId?: string;
    itemCount?: number;
    flagName?: string;
    flagValue?: boolean | number | string;
    eventId?: string;
    specialType?: string;
    specialParams?: Record<string, any>;
    condition?: Condition;
}

interface RandomRange {
    min: number;
    max: number;
}

interface AttributeReference {
    attribute: string;
    multiplier?: number;
}

interface FormulaExpression {
    formula: string;
}

// ============================================
// 条件相关类型
// ============================================

type Condition = 
    | AttributeCondition
    | ItemCondition
    | FlagCondition
    | EventHistoryCondition
    | RandomCondition
    | CharacterCondition;

interface ItemCondition {
    type: 'item';
    params: {
        itemId: string;
        count: number;
        operator: ConditionOperator;
    };
}

interface FlagCondition {
    type: 'flag';
    params: {
        flagName: string;
        flagValue: any;
    };
}

interface RandomCondition {
    type: 'random';
    params: {
        probability: number;
    };
}

// ============================================
// 结局相关类型
// ============================================

interface Ending {
    id: string;
    title: string;
    description: string;
    category: EndingCategory;
    unlockConditions: ConditionGroup[];
    score: EndingScore;
    assets: EndingAssets;
    hidden: boolean;
    unlockHint?: string;
}

interface ConditionGroup {
    conditions: EndingCondition[];
    priority: number;
}

type EndingCondition = 
    | { type: 'attribute'; attribute: string; operator: ConditionOperator; value: number }
    | { type: 'event_triggered'; eventId: string; choiceIndex?: number }
    | { type: 'flag_set'; flagName: string; flagValue: any }
    | { type: 'combination'; conditions: EndingCondition[] };

interface EndingScore {
    base: number;
    modifiers: ScoreModifier[];
}

interface ScoreModifier {
    condition: EndingCondition;
    value: number;
}

interface EndingAssets {
    background: string;
    achievement?: string;
    music?: string;
}

// ============================================
// 物品相关类型
// ============================================

interface Item {
    id: string;
    name: string;
    description: string;
    category: ItemCategory;
    useEffect?: Effect[];
    passiveEffect?: Effect;
    consumable: boolean;
    maxStack: number;
    value: number;
    icon: string;
}

// ============================================
// 游戏状态相关类型
// ============================================

interface GameState {
    meta: GameMeta;
    progress: GameProgress;
    character: CharacterRef;
    attributes: Attributes;
    inventory: Inventory;
    eventHistory: EventRecord[];
    flags: Flags;
    pendingEvents: PendingEvent[];
    triggeredOnceEvents: string[];
    statistics: GameStatistics;
    system?: SystemState;
}

interface GameMeta {
    version: string;
    startTime: number;
    lastSaveTime: number;
    playCount: number;
}

interface GameProgress {
    currentDay: number;
    currentPeriod: number;
    totalPeriods: number;
}

interface CharacterRef {
    id: string;
    name: string;
}

interface Inventory {
    [itemId: string]: number;
}

interface EventRecord {
    eventId: string;
    day: number;
    period: number;
    choiceIndex: number;
    choiceId: string;
    timestamp: number;
}

interface Flags {
    [flagName: string]: any;
}

interface PendingEvent {
    eventId: string;
    triggerDay?: number;
    triggerPeriod?: number;
    priority: number;
}

interface GameStatistics {
    totalEvents: number;
    totalChoices: number;
    moneySpent: number;
    moneyEarned: number;
    redEnvelopesGiven: number;
    redEnvelopesReceived: number;
    mealsEaten: number;
    relativesMet: number;
}

interface SystemState {
    achievements: string[];
    unlockedCharacters: string[];
    unlockedEndings: string[];
    settings: GameSettings;
}

interface GameSettings {
    soundVolume: number;
    musicVolume: number;
    textSpeed: number;
    language: string;
}
```

### 6.2 预设数据参考

#### 6.2.1 预设角色初始属性
```javascript
const PRESET_CHARACTERS = {
    programmer: {
        name: '程序员小王',
        attributes: { money: 30000, weight: 70, face: 50, mood: 60, health: 65, luck: 50 }
    },
    teacher: {
        name: '教师小李',
        attributes: { money: 15000, weight: 58, face: 70, mood: 65, health: 75, luck: 55 }
    },
    doctor: {
        name: '医生小张',
        attributes: { money: 25000, weight: 65, face: 65, mood: 55, health: 70, luck: 50 }
    },
    freelancer: {
        name: '自由职业者',
        attributes: { money: 10000, weight: 62, face: 45, mood: 70, health: 60, luck: 70 }
    },
    student: {
        name: '大学生小陈',
        attributes: { money: 2000, weight: 60, face: 40, mood: 75, health: 80, luck: 60 }
    },
    entrepreneur: {
        name: '创业者小刘',
        attributes: { money: 50000, weight: 75, face: 60, mood: 50, health: 55, luck: 45 }
    },
    civil_servant: {
        name: '公务员小赵',
        attributes: { money: 20000, weight: 68, face: 75, mood: 60, health: 70, luck: 55 }
    },
    artist: {
        name: '艺术家小吴',
        attributes: { money: 8000, weight: 55, face: 55, mood: 80, health: 65, luck: 65 }
    },
    sales: {
        name: '销售小周',
        attributes: { money: 20000, weight: 67, face: 80, mood: 70, health: 65, luck: 55 }
    },
    unemployed: {
        name: '待业青年小马',
        attributes: { money: 5000, weight: 63, face: 30, mood: 45, health: 70, luck: 40 }
    }
};
```

#### 6.2.2 属性边界常量
```javascript
const ATTRIBUTE_BOUNDS = {
    money: { min: -50000, max: 100000 },
    weight: { min: 30, max: 200 },
    face: { min: 0, max: 100 },
    mood: { min: 0, max: 100 },
    health: { min: 0, max: 100 },
    luck: { min: 0, max: 100 }
};

const ATTRIBUTE_DISPLAY_NAMES = {
    money: '存款',
    weight: '体重',
    face: '面子',
    mood: '心情',
    health: '健康',
    luck: '运气'
};

const ATTRIBUTE_ICONS = {
    money: '💰',
    weight: '⚖️',
    face: '👔',
    mood: '😊',
    health: '❤️',
    luck: '🍀'
};
```

#### 6.2.3 时间系统常量
```javascript
const TIME_CONFIG = {
    totalDays: 9,
    periodsPerDay: 3,
    periodNames: ['早上', '中午', '晚上'],
    dayNames: [
        '腊月二十九',
        '除夕',
        '初一',
        '初二',
        '初三',
        '初四',
        '初五',
        '初六',
        '初七'
    ],
    specialDays: {
        2: { name: '除夕', description: '年夜饭、守岁' },
        3: { name: '初一', description: '拜年、放鞭炮' },
        9: { name: '初七', description: '人日、返程' }
    }
};
```

### 6.3 事件设计模板

#### 6.3.1 标准事件模板
```json
{
    "id": "event_template",
    "title": "事件标题",
    "description": "事件描述文本，支持{变量}替换",
    "category": "family",
    "triggerConditions": [
        {
            "type": "time",
            "params": { "days": [1, 2, 3], "periods": [0, 1, 2] }
        },
        {
            "type": "attribute",
            "params": { "attribute": "money", "operator": ">=", "value": 1000 }
        }
    ],
    "weight": 100,
    "onceOnly": false,
    "options": [
        {
            "id": "option_1",
            "text": "选项1文本",
            "effects": [
                { "type": "attribute", "attribute": "money", "value": -100 },
                { "type": "attribute", "attribute": "mood", "value": 10 }
            ],
            "feedback": {
                "text": "选择后的反馈文本"
            }
        },
        {
            "id": "option_2",
            "text": "选项2文本",
            "visibilityConditions": [
                { "type": "attribute", "params": { "attribute": "face", "operator": ">=", "value": 50 } }
            ],
            "effects": [
                { "type": "attribute", "attribute": "face", "value": 5 }
            ]
        }
    ],
    "assets": {
        "background": "assets/events/template_bg.jpg",
        "icon": "assets/icons/template_icon.png"
    }
}
```

### 6.4 开发检查清单

#### 6.4.1 数据结构实现检查
- [ ] Character 接口实现
- [ ] Event 接口实现
- [ ] Option 接口实现
- [ ] Effect 接口实现
- [ ] Ending 接口实现
- [ ] GameState 接口实现
- [ ] SaveData 接口实现

#### 6.4.2 核心系统实现检查
- [ ] 事件触发系统
- [ ] 属性计算系统
- [ ] 结局判定系统
- [ ] 存档管理系统
- [ ] 数据验证系统

#### 6.4.3 JSON数据检查
- [ ] 角色数据JSON格式验证
- [ ] 事件数据JSON格式验证
- [ ] 结局数据JSON格式验证
- [ ] 游戏配置JSON格式验证
- [ ] 存档数据JSON格式验证

#### 6.4.4 功能测试检查
- [ ] 角色选择功能
- [ ] 事件触发功能
- [ ] 选项选择功能
- [ ] 属性变化功能
- [ ] 存档/读档功能
- [ ] 结局判定功能

---

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档版本 | v1.0.0 |
| 最后更新 | 2024年 |
| 作者 | 系统策划 |
| 状态 | 已完成 |

---

**本文档为《春节模拟器》游戏的完整系统架构设计文档，包含数据结构、JSON规范、核心机制和存档系统的详细设计。程序开发人员可根据本文档直接进行实现。**
